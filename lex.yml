if(ft_strchr(cmdline, '<'))
	{
		t_heredoc *hd;
		hd = malloc(sizeof(t_heredoc));
		while(1)
		{
			hd->hd_term = readline("heredoc> ");
			hd->heredoc = ft_strjoin(hd->heredoc, hd->hd_term);
			if(ft_strchr(hd->hd_term, '{'))
				break;
			hd->heredoc = ft_strjoin(hd->heredoc, "\n");
		}
		printf("%s\n", hd->heredoc); 
	}
/////////////////////////////////////////////////
if(syntax_handling(tokens))
		{
			commands = malloc(sizeof(t_cmdline));
			if(!commands)
				return (NULL);
			commands->cmds = parse(tokens, table, envp);
			if(commands->cmds)
				return (commands);
		}
		else
			return (NULL);
/////////////////////////////////////////////////
	int main(void)
{
	 id1 = fork(){
		 id1 = ?
		 main = parentProcessId
		 id2 = fork(){
			 id1 = parentProcessId
			 id2 = ?
			 printf("ok");
		 }
		 printf("ok");
	 }
	 id2 = fork(){
		 id1 = parentProcessId
		 printf("ok");
	 }


	 static void print_arguments(t_cmds **commands)
{
	while(*commands != NULL)
	{
		printf("%s\n", (*commands)->arguments);
		commands = &(*commands)->next;
	}
}

	 printf("ok");
}

   // if(typeis_pipe((*token)->type))
        //     //do something
        // if(typeis_redir((*token)->type))
        //     //do something

char *abc = echo                   hello                    world
split(abc, ' '); -> ["echo", "hello", "world"]

char *def = echo     hello         "$USER      world"        barev
						echo     hello         userworld               barev
split(def, ' '); -> ["echo", "hello", "userworld", "barev"];
										token_replace(def[i], 3, ' ');







// while(table->token != NULL)
// {
//     printf("[%s] : %d\n", table->token->tok, table->token->type);
//     table->token = table->token->next;
// }
 // printf("%s\n", tree->cmds->arg_pack[2]);
        // if(tree)
        //     execute_command(tree, table, envp);









(*table)->heredoc = malloc(sizeof(t_heredoc));
	if(contains("<<", cmdline, &pos))
	{
		int end;
		
		end = find_space_orpipe(cmdline+pos);
		(*table)->heredoc->delimiter = ft_substr(cmdline, pos, end);
	}
Parsing steps

Step 1: Check TYPE of token if WORD | SPACE | EXP_FIELD
	Substep 1.0: Input -> echo user[hided spaces]helloworld
	Substep 1.1: Count all characters of (WORD && SPACE && EXP_FIELD)
	Substep 1.2: Join all WORD | SPACE | EXP_FIELD
					if(token->type == WORD || token->type == EXP_FIELD || token->type == SEP)
										join_tokens();
	Substep 1.3: Output -> "echo userhelloworld"
	Substep 1.4: Split by spaces
						split = ["echo", "userhelloworld"]
	Substep 1.5: replace hided spaces in exp_fields
						token_replacment(split[i], 3, ' ');
	Substep 1.6: Output -> split = ["echo", "user helloworld"]
	


echo "user hello"world

	echo "userhello"world
	echo userhelloworld
	if(token->type == WORD || token->type == EXP_FIELD || token->type == SEP)
		join_tokens();
		echo userhelloworld

			replace("userhello", 3, ' ');
			
		echo user helloworld
			
			# if(cmdline[i] == '|')
			# 	cmdline[i] = 5;

		// if (cmdline[i] && (cmdline[i] == '\"' || cmdline[i] == '\''))
		// 	expansion(cmdline, &i, cmdline[i], &tokens);

///usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

		// if(cmdline[i] == '>')
		// 	redirection(cmdline, &i, tokens, '>');
		// if(cmdline[i] == '<')
		// 	redirection(cmdline, &i, tokens, '<');
		// if(cmdline[i] == '|')
		// 	pipe(cmdline, &i, tokens);

		// while(table->token != NULL)
		// {
		// 	printf("%s\n", table->token->tok);
		// 	table->token = table->token->next;
		// }

   // echo "hello             ho?" how are you $USER | > out

  // gcc -lreadline env/*.c utils/*.c lex/*c libft/libft.a  minishell.c -o minishell && ./minishell
 //gcc  env/*.c utils/*.c lex/*c libft/libft.a  minishell.c -o minishell -lreadline && ./minishell
// gcc env/*.c utils/*.c libft/libft.a  minishell.c -o minishell
////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
//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


typedef struct s_heredoc
{
    char *term;
	char *delimiter;
	char *heredoc;
} t_heredoc;

typedef struct s_cmds
{
    char    *fullcmd;
    char    *path;
    int     istream;
    int     ostream;
}   t_cmds;



static int char_by_char(char *tok, char *cmdline, int *j, int *c, int *count);

// int char_by_char(char *tok, char *cmdline, int *j, int *c, int *count)
// {
// 	int flag;

// 	flag = 0;
// 	while(tok[*c])
// 	{
// 		if(cmdline[*j] == tok[*c])
// 		{
// 			++count;
// 			flag++;
// 			j++;
// 		}
// 		c++;
// 	}
// 	// printf("%s : %s\n", tok, cmdline);
// 	return (flag);
// }



token_replacment(cmdline, '\'', '\a');
	// cmdline = find_replace(cmdline, (*table)->env);
	printf("%s\n", cmdline);
	token_replacment(cmdline, '\a', '\'');
	printf("%s\n", cmdline);




// int main(int ac, char *av[], char **envp)
// {
// 	const char *CAP_LETTERS;
// 	const char *SML_LETTERS;
// 	CAP_LETTERS = "A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z";
// 	SML_LETTERS = "a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z";
// 	char **lex = ft_split(CAP_LETTERS, '|');
// 	int i = -1;
// 	while(envp[++i])
// 		printf("%s\n", envp[i]);
// }



if(contains("<<", cmdline, &pos))
	{
		int end;
		
		end = find_space_orpipe(cmdline+pos);
		(*table)->heredoc->delimiter = ft_substr(cmdline, pos, end);
		printf("%s\n", (*table)->heredoc->delimiter);
	}



int contains(char *tok, char *cmdline)
{
	// tok -> |
	// cmdline -> abc | x=
	int i;
	int c;
	int j;
	int len;
	int flag;

	i = -1;
	len = ft_strlen(tok);
	while(cmdline[++i])
	{
		c = -1;
		j = i;
		if(cmdline[j] == tok[++c])
		{
			flag = 1;
			while(tok[c + 1] != '\0' && tok[++c])
				if(cmdline[++j] == tok[c])
					flag++;
			printf("flag: %d\n", flag);
			printf("len: %d\n", len);
			if(flag == len && cmdline[++j] != tok[c])
			{
				printf("c: %d\n", c);
				printf("cmdline[++j]: %c\n", cmdline[j]);
				printf("tok[c]: %c\n", tok[c]);
				printf("return 1\n");
				return (1);
			}
		}
	}
	return (0);
}


//finished but have a mistakes
int contains(char *tok, char *cmdline, int *pos)
{
	int i;
	int c;
	int j;
	int len;
	int flag;

	i = -1;
	len = ft_strlen(tok);
	while(cmdline[++i])
	{
		c = 0;
		j = i;
		if(cmdline[j] == tok[c])
		{
			flag = 0;
			while(tok[c])
			{
				if(cmdline[j] == tok[c])
				{
					flag++;
					j++;
				}
				c++;
			}
			if(cmdline[j] == tok[c - 1])
			{
				i = j;
				continue;
			}
			if(flag == len)
			{
				*pos = j;
				return (1);
			}
			i = j;
		}
	}
	return (0);
}

 		int i;
    t_cmds *cmd;
    pid_t pid;
    int builtin;
    int executable;

    cmd = (*commands)->cmds;
    while(cmd != NULL)
    {
        
        pid = fork();
        if(pid == 0)
        {
            builtin = find_in(cmd->arg_pack[0], (*table)->reserved);
            executable = cmd_check(cmd, (*table)->paths);
            if(builtin != -1)
            {
                printf("inside : %s\n", cmd->arg_pack[1]);
                (*table)->builtin[builtin](*commands, *table);
                exit(1);
            }
            else if(executable != -1)
            {
                execve(cmd->path, cmd->arg_pack, 0);
                exit(1);   
            }
            else
            {
                printf("Command: %s Not found", cmd->arg_pack[0]);
                exit(1);
            }
        }
        waitpid(-1, 0, 0);
        cmd = cmd->next;
    }